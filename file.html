<!DOCTYPE html>
<html lang="en"> <!-- Default language, will be updated by JS -->

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title data-i18n="title">FileBridge - Secure File Sharing</title>
    <!-- (Optional) Crypto-JS for hashing (CDN) or use built-in SubtleCrypto -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>

    <style>
        /* (前回提示したCSSスタイルをここにコピー＆ペースト) */
        /* Reset and Basic Styles */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #1e1e2f 0%, #1c1c33 100%);
            color: #e0e0e0;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow-x: hidden;
            padding: 20px;
        }

        .container {
            background: rgba(40, 42, 54, 0.85);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            padding: 30px 40px;
            width: 100%;
            max-width: 650px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
            margin-bottom: 20px;
        }

        .header {
            margin-bottom: 20px;
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 700;
            color: #50fa7b;
            letter-spacing: 1px;
            text-shadow: 0 0 10px rgba(80, 250, 123, 0.5);
        }

        .header p {
            font-size: 1em;
            color: #bd93f9;
            margin-top: 5px;
        }

        .language-selector {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(40, 42, 54, 0.9);
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }

        .language-selector select {
            background: transparent;
            color: #f8f8f2;
            border: none;
            outline: none;
            font-size: 0.9em;
        }

        .language-selector option {
            background: #282a36;
            color: #f8f8f2;
        }

        .tabs {
            display: flex;
            justify-content: center;
            margin-bottom: 25px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .tab-button {
            background: none;
            border: none;
            color: #f8f8f2;
            padding: 12px 20px;
            cursor: pointer;
            font-size: 1.05em;
            font-weight: 600;
            transition: color 0.3s, border-bottom 0.3s;
            position: relative;
        }

        .tab-button.active {
            color: #50fa7b;
        }

        .tab-button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 100%;
            height: 2px;
            background-color: #50fa7b;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .drop-zone {
            border: 3px dashed #6272a4;
            border-radius: 10px;
            padding: 40px 20px;
            margin-bottom: 15px;
            cursor: pointer;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .drop-zone.dragover {
            background-color: rgba(98, 114, 164, 0.2);
            border-color: #bd93f9;
        }

        .drop-zone p {
            font-size: 1.1em;
            color: #f8f8f2;
        }

        .drop-zone span {
            color: #8be9fd;
            text-decoration: underline;
            cursor: pointer;
        }

        #fileInput {
            display: none;
        }

        #fileListContainer,
        #receivedFileListContainer {
            margin-top: 10px;
            text-align: left;
            max-height: 200px;
            overflow-y: auto;
            padding-right: 10px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.1);
        }

        #fileListContainer .file-item,
        #receivedFileListContainer .file-item {
            background: rgba(255, 255, 255, 0.05);
            padding: 8px 12px;
            border-radius: 5px;
            margin-bottom: 8px;
            font-size: 0.9em;
            word-break: break-all;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .file-item-name {
            flex-grow: 1;
            margin-right: 10px;
        }

        .file-item-progress {
            font-size: 0.8em;
            color: #8be9fd;
            min-width: 40px;
            text-align: right;
        }

        .connection-info-container {
            margin-top: 20px;
            padding: 15px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
        }

        .connection-info-container p {
            font-size: 1.1em;
            color: #f8f8f2;
            margin-bottom: 8px;
        }

        #generatedCodeDisplay,
        #connectCodeInput {
            font-size: 2em;
            /* Larger for 6-digit code */
            font-weight: bold;
            color: #ffb86c;
            letter-spacing: 3px;
            /* Spacing for digits */
            padding: 10px 15px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 5px;
            display: inline-block;
            word-break: break-all;
            margin-bottom: 10px;
            font-family: 'Courier New', Courier, monospace;
            /* Monospaced for code */
        }

        #connectCodeInput {
            width: 100%;
            padding: 15px;
            /* Larger input */
            font-size: 1.5em;
            border-radius: 8px;
            border: 2px solid #6272a4;
            background-color: #282a36;
            color: #f8f8f2;
            text-align: center;
            letter-spacing: 2px;
        }

        #connectCodeInput:focus {
            outline: none;
            border-color: #bd93f9;
            box-shadow: 0 0 10px rgba(189, 147, 249, 0.5);
        }

        .btn {
            background: linear-gradient(135deg, #8be9fd, #50fa7b);
            color: #282a36;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.05em;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.3s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            margin-top: 10px;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(80, 250, 123, 0.4);
        }

        .btn:disabled {
            background: #6272a4;
            color: #44475a;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .status-message {
            margin-top: 15px;
            font-size: 1em;
            color: #ffb86c;
            min-height: 1.2em;
        }

        .overall-progress-container {
            width: 100%;
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 5px;
            margin-top: 15px;
            display: none;
        }

        .overall-progress-bar {
            width: 0%;
            height: 20px;
            background: linear-gradient(90deg, #ff79c6, #bd93f9);
            border-radius: 5px;
            text-align: center;
            line-height: 20px;
            color: #f8f8f2;
            font-weight: bold;
            transition: width 0.1s ease-out;
        }

        .footer {
            margin-top: auto;
            padding-top: 20px;
            width: 100%;
            text-align: center;
            font-size: 0.9em;
            color: #6272a4;
        }

        .footer p {
            margin-bottom: 5px;
        }

        .footer a {
            color: #8be9fd;
            text-decoration: none;
        }

        .footer a:hover {
            text-decoration: underline;
        }
    </style>
</head>

<body>
    <div class="language-selector">
        <select id="languageSwitcher" onchange="switchLanguage(this.value)">
            <option value="en">English</option>
            <option value="ja">日本語</option>
            <option value="zh">中文</option>
            <option value="ko">한국어</option>
        </select>
    </div>

    <div class="container">
        <div class="header">
            <h1 data-i18n="appTitle">FileBridge</h1>
            <p data-i18n="appSubtitle">Instant, Secure, Cross-Platform File Sharing</p>
        </div>

        <div class="tabs">
            <button class="tab-button active" onclick="showTab('sendTab')" data-i18n="sendTab">Send</button>
            <button class="tab-button" onclick="showTab('receiveTab')" data-i18n="receiveTab">Receive</button>
        </div>

        <!-- Send Tab Content -->
        <div id="sendTab" class="tab-content active">
            <div id="dropZone" class="drop-zone">
                <p data-i18n="dropZoneText">Drag & Drop files here, or <span data-i18n="dropZoneClick"
                        onclick="fileInput.click()">click to select</span>.</p>
                <input type="file" id="fileInput" multiple>
            </div>
            <div id="fileListContainer">
                <!-- Selected files will be listed here -->
            </div>
            <button id="sendButton" class="btn" disabled data-i18n="generateCodeButton">Generate Share Code</button>
            <div id="connectionInfoContainerSend" class="connection-info-container" style="display: none;">
                <p data-i18n="shareCodePrompt">Share this code with the receiver:</p>
                <div id="generatedCodeDisplay">------</div>
            </div>
            <div id="sendOverallProgressContainer" class="overall-progress-container">
                <div id="sendOverallProgressBar" class="overall-progress-bar">0%</div>
            </div>
            <p id="sendStatus" class="status-message"></p>
        </div>

        <!-- Receive Tab Content -->
        <div id="receiveTab" class="tab-content">
            <div class="input-group">
                <label for="connectCodeInput" data-i18n="enterCodeLabel">Enter 6-Digit Share Code:</label>
                <input type="text" id="connectCodeInput" placeholder="XXXXXX" maxlength="6">
            </div>
            <button id="receiveButton" class="btn" data-i18n="connectButton">Connect & Receive</button>
            <div id="receivedFileListContainer">
                <!-- Received files will be listed here -->
            </div>
            <div id="receiveOverallProgressContainer" class="overall-progress-container">
                <div id="receiveOverallProgressBar" class="overall-progress-bar">0%</div>
            </div>
            <p id="receiveStatus" class="status-message"></p>
        </div>
    </div>

    <div class="footer">
        <p><a href="privacy.html" target="_blank" data-i18n="privacyPolicy">Privacy Policy</a></p>
        <p>© 2025 <a href="https://dazzling-childlike-bookcase.glitch.me" target="_blank">2025 Nest App</a>. <span
                data-i18n="rightsReserved">All rights reserved.</span></p>
    </div>

    <script>
        // --- i18n (translations object from previous response) ---
        const translations = { /* ... (前回と同じ翻訳オブジェクト) ... */
            en: {
                title: "FileBridge - Secure File Sharing",
                appTitle: "FileBridge",
                appSubtitle: "Instant, Secure, Cross-Platform File Sharing",
                sendTab: "Send",
                receiveTab: "Receive",
                dropZoneText: "Drag & Drop files here, or ",
                dropZoneClick: "click to select",
                generateCodeButton: "Generate Share Code",
                shareCodePrompt: "Share this code with the receiver:",
                enterCodeLabel: "Enter 6-Digit Share Code:",
                connectButton: "Connect & Receive",
                privacyPolicy: "Privacy Policy",
                rightsReserved: "All rights reserved.",
                noFilesSelected: "Please select files first.",
                initializingSender: "Initializing...",
                shareCodeGenerated: "Share Code generated. Waiting for receiver...",
                waitingForSenderCode: "Waiting for Sender's Code...",
                connecting: "Connecting...",
                connectionEstablished: "Connection established!",
                sendingFiles: "Sending files...",
                receivingFiles: "Receiving files...",
                transferComplete: "Transfer complete!",
                transferFailed: "Transfer failed.",
                fileSent: "sent",
                fileReceived: "received",
                error: "Error",
                wsError: "Signaling Error. Check console.",
                dataError: "Data channel error.",
                fileReadError: "Error reading file.",
                disconnected: "Disconnected.",
                invalidCode: "Invalid Share Code.",
                calculatingHash: "Calculating hash...",
                verifyingHash: "Verifying hash...",
                hashMismatch: "File integrity check failed (hash mismatch). Please try again.",
                fileIntegrityOk: "File integrity OK.",
                filePlaceholder: "Select files to send.",
                downloadButtonText: "Download",
                sessionTimeout: "Session timed out. Please generate a new code.",
                peerLeft: "The other user has left the session.",
                sessionFull: "This session is already full."
            },
            ja: {
                title: "FileBridge - 安全なファイル共有",
                appTitle: "FileBridge",
                appSubtitle: "瞬時に安全なクロスプラットフォームファイル共有",
                sendTab: "送信",
                receiveTab: "受信",
                dropZoneText: "ここにファイルをドラッグ＆ドロップ、または",
                dropZoneClick: "クリックして選択",
                generateCodeButton: "共有コードを生成",
                shareCodePrompt: "このコードを受信者と共有してください:",
                enterCodeLabel: "6桁の共有コードを入力:",
                connectButton: "接続して受信",
                privacyPolicy: "プライバシーポリシー",
                rightsReserved: "無断複写・転載を禁じます。",
                noFilesSelected: "まずファイルを選択してください。",
                initializingSender: "初期化中...",
                shareCodeGenerated: "共有コードが生成されました。受信者を待っています...",
                waitingForSenderCode: "送信者のコードを待っています...",
                connecting: "接続中...",
                connectionEstablished: "接続が確立されました！",
                sendingFiles: "ファイルを送信中...",
                receivingFiles: "ファイルを受信中...",
                transferComplete: "転送完了！",
                transferFailed: "転送に失敗しました。",
                fileSent: "送信完了",
                fileReceived: "受信完了",
                error: "エラー",
                wsError: "シグナリングエラー。コンソールを確認してください。",
                dataError: "データチャネルエラー。",
                fileReadError: "ファイル読み込みエラー。",
                disconnected: "切断されました。",
                invalidCode: "無効な共有コードです。",
                calculatingHash: "ハッシュを計算中...",
                verifyingHash: "ハッシュを検証中...",
                hashMismatch: "ファイルの整合性チェックに失敗しました（ハッシュ不一致）。再試行してください。",
                fileIntegrityOk: "ファイルの整合性OK。",
                filePlaceholder: "送信するファイルを選択してください。",
                downloadButtonText: "ダウンロード",
                sessionTimeout: "セッションがタイムアウトしました。新しいコードを生成してください。",
                peerLeft: "相手がセッションを離れました。",
                sessionFull: "このセッションは既にいっぱいです。"
            },
            zh: {
                title: "FileBridge - 安全文件共享",
                appTitle: "FileBridge",
                appSubtitle: "即时、安全、跨平台文件共享",
                sendTab: "发送",
                receiveTab: "接收",
                dropZoneText: "将文件拖放到此处，或",
                dropZoneClick: "点击选择",
                generateCodeButton: "生成共享代码",
                shareCodePrompt: "与接收者分享此代码:",
                enterCodeLabel: "输入6位共享代码:",
                connectButton: "连接并接收",
                privacyPolicy: "隐私政策",
                rightsReserved: "版权所有。",
                noFilesSelected: "请先选择文件。",
                initializingSender: "正在初始化...",
                shareCodeGenerated: "共享代码已生成。正在等待接收方...",
                waitingForSenderCode: "正在等待发送方的代码...",
                connecting: "连接中...",
                connectionEstablished: "连接已建立！",
                sendingFiles: "正在发送文件...",
                receivingFiles: "正在接收文件...",
                transferComplete: "传输完成！",
                transferFailed: "传输失败。",
                fileSent: "已发送",
                fileReceived: "已接收",
                error: "错误",
                wsError: "信令错误。请检查控制台。",
                dataError: "数据通道错误。",
                fileReadError: "读取文件错误。",
                disconnected: "已断开连接。",
                invalidCode: "无效的共享代码。",
                calculatingHash: "正在计算哈希值...",
                verifyingHash: "正在验证哈希值...",
                hashMismatch: "文件完整性检查失败（哈希值不匹配）。请重试。",
                fileIntegrityOk: "文件完整性良好。",
                filePlaceholder: "选择要发送的文件。",
                downloadButtonText: "下载",
                sessionTimeout: "会话超时。请生成新代码。",
                peerLeft: "对方已离开会话。",
                sessionFull: "此会话已满。"
            },
            ko: {
                title: "FileBridge - 안전한 파일 공유",
                appTitle: "FileBridge",
                appSubtitle: "즉각적이고 안전한 크로스 플랫폼 파일 공유",
                sendTab: "보내기",
                receiveTab: "받기",
                dropZoneText: "여기에 파일을 드래그 앤 드롭하거나 ",
                dropZoneClick: "클릭하여 선택",
                generateCodeButton: "공유 코드 생성",
                shareCodePrompt: "이 코드를 수신자와 공유하십시오:",
                enterCodeLabel: "6자리 공유 코드를 입력하십시오:",
                connectButton: "연결 및 수신",
                privacyPolicy: "개인정보 처리방침",
                rightsReserved: "모든 권리 보유.",
                noFilesSelected: "먼저 파일을 선택하십시오.",
                initializingSender: "초기화 중...",
                shareCodeGenerated: "공유 코드가 생성되었습니다. 수신자를 기다리는 중...",
                waitingForSenderCode: "발신자의 코드를 기다리는 중...",
                connecting: "연결 중...",
                connectionEstablished: "연결되었습니다!",
                sendingFiles: "파일 보내는 중...",
                receivingFiles: "파일 받는 중...",
                transferComplete: "전송 완료!",
                transferFailed: "전송 실패.",
                fileSent: "보냄",
                fileReceived: "받음",
                error: "오류",
                wsError: "신호 오류. 콘솔을 확인하십시오.",
                dataError: "데이터 채널 오류.",
                fileReadError: "파일 읽기 오류.",
                disconnected: "연결 끊김.",
                invalidCode: "잘못된 공유 코드입니다.",
                calculatingHash: "해시 계산 중...",
                verifyingHash: "해시 확인 중...",
                hashMismatch: "파일 무결성 검사 실패 (해시 불일치). 다시 시도하십시오.",
                fileIntegrityOk: "파일 무결성 확인됨.",
                filePlaceholder: "보낼 파일을 선택하세요.",
                downloadButtonText: "다운로드",
                sessionTimeout: "세션 시간 초과. 새 코드를 생성하십시오.",
                peerLeft: "상대방이 세션을 떠났습니다.",
                sessionFull: "이 세션은 이미 가득 찼습니다."
            }
        };
        let currentLanguage = 'en';
        function _(key, fallback) { return translations[currentLanguage]?.[key] || translations['en']?.[key] || fallback || key; }
        function applyTranslations() {
            document.querySelectorAll('[data-i18n]').forEach(el => {
                const key = el.getAttribute('data-i18n');
                const fallbackText = el.textContent || el.value || el.placeholder || '';
                if (el.tagName === 'INPUT' && el.type === 'button' || el.tagName === 'BUTTON') {
                    el.value = _(key, fallbackText);
                    if (el.tagName === 'BUTTON') el.textContent = _(key, fallbackText);
                } else if (el.tagName === 'INPUT' && el.placeholder) {
                    el.placeholder = _(key, fallbackText);
                } else if (el.tagName === 'TITLE') {
                    document.title = _(key, fallbackText);
                }
                else {
                    el.textContent = _(key, fallbackText);
                }
            });
            const fileListContainerEl = document.getElementById('fileListContainer');
            if (fileListContainerEl && !fileListContainerEl.hasChildNodes()) {
                const placeholder = document.createElement('p');
                placeholder.classList.add('file-item-placeholder'); // クラス追加
                placeholder.textContent = _('filePlaceholder');
                placeholder.style.textAlign = 'center';
                placeholder.style.color = '#6272a4';
                placeholder.style.padding = '20px 0'; // 余白調整
                placeholder.style.background = 'none'; // 背景をリセット
                fileListContainerEl.appendChild(placeholder);
            }
        }
        function switchLanguage(lang) {
            if (translations[lang]) {
                currentLanguage = lang;
                document.documentElement.lang = lang;
                localStorage.setItem('preferredLanguage', lang);
                applyTranslations();
            }
        }

        // --- DOM Elements ---
        const generatedCodeDisplay = document.getElementById('generatedCodeDisplay');
        const connectCodeInput = document.getElementById('connectCodeInput');
        const sendTabButton = document.querySelectorAll('.tab-button')[0];
        const receiveTabButton = document.querySelectorAll('.tab-button')[1];
        // const sendTabEl = document.getElementById('sendTab'); // 未使用なのでコメントアウト
        // const receiveTabEl = document.getElementById('receiveTab'); // 未使用なのでコメントアウト
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const fileListContainer = document.getElementById('fileListContainer');
        const sendButton = document.getElementById('sendButton');
        const connectionInfoContainerSend = document.getElementById('connectionInfoContainerSend');
        const sendStatusEl = document.getElementById('sendStatus');
        const sendOverallProgressContainer = document.getElementById('sendOverallProgressContainer');
        const sendOverallProgressBar = document.getElementById('sendOverallProgressBar');
        const receiveButton = document.getElementById('receiveButton');
        const receivedFileListContainer = document.getElementById('receivedFileListContainer');
        const receiveOverallProgressContainer = document.getElementById('receiveOverallProgressContainer');
        const receiveOverallProgressBar = document.getElementById('receiveOverallProgressBar');
        const receiveStatusEl = document.getElementById('receiveStatus');


        // --- WebSocket and WebRTC Variables ---
        const SIGNALING_SERVER_URL = 'wss://dazzling-childlike-bookcase.glitch.me'; // ★★★ GlitchのURLに更新 ★★★
        let ws;
        let peerConnection;
        let dataChannel;
        let current6DigitCode = null;
        let isOfferer = false;

        let selectedFiles = [];
        let currentFileIndex = 0;
        let totalBytesToSend = 0;
        let totalBytesSent = 0;
        let totalBytesToReceive = 0;
        let totalBytesReceived = 0;
        const CHUNK_SIZE = 64 * 1024;
        let receivingFile = { name: null, size: null, mimeType: null, hash: null, buffer: [], receivedBytes: 0, totalFiles: 0, currentFileNum: 0, elementId: null };


        // --- Helper Functions ---
        function log(...args) { console.log("[FileBridge]", ...args); }
        function logError(...args) { console.error("[FileBridge ERROR]", ...args); }
        function formatBytes(bytes, decimals = 2) {
            if (bytes === 0) return '0 Bytes'; const k = 1024; const dm = decimals < 0 ? 0 : decimals; const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB']; const i = Math.floor(Math.log(bytes) / Math.log(k)); return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
        }
        async function calculateFileHash(file) {
            if (window.crypto && window.crypto.subtle) { const buffer = await file.arrayBuffer(); const hashBuffer = await crypto.subtle.digest('SHA-256', buffer); const hashArray = Array.from(new Uint8Array(hashBuffer)); return hashArray.map(b => b.toString(16).padStart(2, '0')).join(''); } else { return new Promise((resolve, reject) => { const reader = new FileReader(); reader.onload = (e) => { const wordArray = CryptoJS.lib.WordArray.create(e.target.result); const hash = CryptoJS.SHA256(wordArray).toString(CryptoJS.enc.Hex); resolve(hash); }; reader.onerror = (err) => reject(err); reader.readAsArrayBuffer(file); }); }
        }


        // --- Tab Functionality ---
        function showTab(tabId) {
            const contents = document.querySelectorAll('.tab-content');
            contents.forEach(content => content.classList.remove('active'));
            document.getElementById(tabId).classList.add('active');

            const buttons = document.querySelectorAll('.tab-button');
            buttons.forEach(button => button.classList.remove('active'));
            if (tabId === 'sendTab') {
                sendTabButton.classList.add('active');
            } else {
                receiveTabButton.classList.add('active');
            }
            resetStatesForTabSwitch();
        }

        function resetStatesForTabSwitch() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                if (current6DigitCode) ws.send(JSON.stringify({ type: 'hangup', code: current6DigitCode }));
                // ws.close(); // すぐに閉じるとhangupが届かない可能性があるので、サーバー側でタイムアウトや重複接続で処理させる
            }
            // ws = null; // WebSocketインスタンスはタブ切り替えでは再利用しない方が安全かも
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            dataChannel = null;
            current6DigitCode = null;
            isOfferer = false;

            generatedCodeDisplay.textContent = "------";
            connectionInfoContainerSend.style.display = 'none';
            connectCodeInput.value = '';
            connectCodeInput.disabled = false; // 再度入力可能に
            sendButton.disabled = selectedFiles.length === 0;
            receiveButton.disabled = false;
            updateStatus(sendStatusEl, '');
            updateStatus(receiveStatusEl, '');
            sendOverallProgressContainer.style.display = 'none';
            sendOverallProgressBar.style.width = '0%'; sendOverallProgressBar.textContent = '0%';
            receiveOverallProgressContainer.style.display = 'none';
            receiveOverallProgressBar.style.width = '0%'; receiveOverallProgressBar.textContent = '0%';

            // プレースホルダー再表示
            const fileListContainerEl = document.getElementById('fileListContainer');
            if (fileListContainerEl) {
                const existingPlaceholder = fileListContainerEl.querySelector('.file-item-placeholder');
                if (!selectedFiles.length && !existingPlaceholder) { // ファイル未選択かつプレースホルダーがない場合
                    fileListContainerEl.innerHTML = ''; // 中身をクリア
                    const placeholder = document.createElement('p');
                    placeholder.classList.add('file-item-placeholder');
                    placeholder.textContent = _('filePlaceholder');
                    placeholder.style.textAlign = 'center';
                    placeholder.style.color = '#6272a4';
                    placeholder.style.padding = '20px 0';
                    placeholder.style.background = 'none';
                    fileListContainerEl.appendChild(placeholder);
                } else if (selectedFiles.length && existingPlaceholder) { // ファイル選択済みでプレースホルダーがある場合
                    existingPlaceholder.remove();
                }
            }
            receivedFileListContainer.innerHTML = '';
        }


        // --- WebSocket Initialization and Handling ---
        function initializeWebSocket() {
            if (ws && (ws.readyState === WebSocket.OPEN || ws.readyState === WebSocket.CONNECTING)) {
                log("WebSocket already open or connecting.");
                return Promise.resolve(ws);
            }

            return new Promise((resolve, reject) => {
                log(`Attempting to connect to WebSocket: ${SIGNALING_SERVER_URL}`);
                ws = new WebSocket(SIGNALING_SERVER_URL);

                ws.onopen = () => {
                    log('Connected to Signaling Server.');
                    resolve(ws);
                };

                ws.onmessage = (event) => {
                    let message;
                    try {
                        message = JSON.parse(event.data);
                        log('Received from signaling server:', message);
                    } catch (e) {
                        logError("Received non-JSON message from signaling server:", event.data);
                        return;
                    }


                    switch (message.type) {
                        case 'code-generated':
                            current6DigitCode = message.code;
                            generatedCodeDisplay.textContent = message.code.match(/.{1,3}/g).join('-');
                            connectionInfoContainerSend.style.display = 'block';
                            updateStatus(sendStatusEl, _('shareCodeGenerated'));
                            createPeerConnectionAndOffer();
                            break;
                        case 'offer':
                            if (!isOfferer) {
                                current6DigitCode = message.code || current6DigitCode; // join時にコードが確定するので、offerメッセージにcodeがなくても良い
                                createPeerConnectionAndAnswer(message.sdp, message.iceCandidates);
                            }
                            break;
                        case 'answer':
                            if (isOfferer && peerConnection) {
                                peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: message.sdp }))
                                    .then(() => {
                                        log('Remote description (answer) set.');
                                        message.iceCandidates?.forEach(candidate => {
                                            if (candidate) peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(logError);
                                        });
                                    })
                                    .catch(e => logError("Error setting remote description (answer):", e));
                            }
                            break;
                        case 'ice-candidate':
                            if (peerConnection && peerConnection.remoteDescription && message.candidate) {
                                peerConnection.addIceCandidate(new RTCIceCandidate(message.candidate))
                                    .catch(e => logError("Error adding received ICE candidate:", e.toString()));
                            } else if (peerConnection && !peerConnection.remoteDescription && message.candidate) {
                                log("Queueing ICE candidate until remote description is set.");
                                // 簡単なキューイング (より堅牢な実装が必要な場合あり)
                                if (!peerConnection._queuedIceCandidates) peerConnection._queuedIceCandidates = [];
                                peerConnection._queuedIceCandidates.push(message.candidate);
                            } else {
                                log("Received ICE candidate but peerConnection or remoteDescription not ready, or candidate missing.");
                            }
                            break;
                        case 'peer-joined-send-offer':
                            if (isOfferer && peerConnection && peerConnection.localDescription && current6DigitCode) {
                                ws.send(JSON.stringify({
                                    type: 'offer',
                                    code: current6DigitCode,
                                    sdp: peerConnection.localDescription.sdp
                                }));
                            }
                            break;
                        case 'session-timeout':
                            if (message.code === current6DigitCode) {
                                updateStatus(isOfferer ? sendStatusEl : receiveStatusEl, _('sessionTimeout'), true);
                                resetStatesForTabSwitch();
                            }
                            break;
                        case 'peer-left':
                            if (message.code === current6DigitCode) {
                                updateStatus(isOfferer ? sendStatusEl : receiveStatusEl, _('peerLeft'), true);
                                resetStatesForTabSwitch();
                            }
                            break;
                        case 'error':
                            logError('Signaling server error:', message.message);
                            const targetStatusEl = isOfferer ? sendStatusEl : receiveStatusEl;
                            updateStatus(targetStatusEl, `${_('wsError')} ${message.message}`, true);

                            if (message.message === _('sessionFull') || message.message.includes(_('invalidCode', 'Invalid code')) || message.message.includes('Session is already full') || message.message.includes('Invalid code or session not found')) {
                                if (!isOfferer) { // 受信側のみボタンを再度有効化
                                    receiveButton.disabled = false;
                                    connectCodeInput.disabled = false;
                                }
                            }
                            break;
                    }
                };

                ws.onclose = (event) => {
                    log('Disconnected from Signaling Server. Code:', event.code, 'Reason:', event.reason);
                    // ユーザー起因でない切断の場合、UIに通知
                    if (!event.wasClean && current6DigitCode) { // current6DigitCode がある＝セッション中だった
                        updateStatus(isOfferer ? sendStatusEl : receiveStatusEl, _('disconnected') + " " + _('wsError'), true);
                    }
                    ws = null;
                    // reject(new Error("WebSocket connection closed.")); // Promiseは既に解決/拒否されている可能性
                };

                ws.onerror = (error) => {
                    logError('WebSocket Error:', error);
                    updateStatus(isOfferer ? sendStatusEl : receiveStatusEl, _('wsError') + " (Connection failed)", true);
                    ws = null;
                    reject(error);
                };
            });
        }

        // --- WebRTC PeerConnection Setup ---
        const iceServers = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun.services.mozilla.com' } // 追加のSTUNサーバー
                // Consider adding TURN servers for more robust connectivity
            ]
        };

        function createPeerConnection() {
            if (peerConnection) {
                log("Closing existing peer connection.");
                peerConnection.close();
            }
            try {
                peerConnection = new RTCPeerConnection(iceServers);
            } catch (e) {
                logError("Failed to create RTCPeerConnection:", e);
                updateStatus(isOfferer ? sendStatusEl : receiveStatusEl, _('error') + ": Cannot create P2P connection.", true);
                return;
            }


            peerConnection.onicecandidate = (event) => {
                if (event.candidate && ws && ws.readyState === WebSocket.OPEN && current6DigitCode) {
                    log("Sending ICE candidate:", event.candidate);
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        code: current6DigitCode,
                        candidate: event.candidate
                    }));
                }
            };

            peerConnection.onicegatheringstatechange = () => {
                log("ICE gathering state change:", peerConnection.iceGatheringState);
            };

            peerConnection.onconnectionstatechange = () => {
                log('PeerConnection state:', peerConnection.connectionState);
                const targetStatusEl = isOfferer ? sendStatusEl : receiveStatusEl;
                switch (peerConnection.connectionState) {
                    case "connected":
                        updateStatus(targetStatusEl, _('connectionEstablished'));
                        if (isOfferer && dataChannel && dataChannel.readyState === 'open' && selectedFiles.length > 0) {
                            startFileTransfer();
                        }
                        break;
                    case "disconnected":
                        updateStatus(targetStatusEl, _('disconnected') + ". Attempting to reconnect...", true);
                        // WebRTCは自動再接続を試みることがある
                        break;
                    case "failed":
                        updateStatus(targetStatusEl, _('connectionFailed') || "P2P Connection Failed.", true);
                        if (ws && ws.readyState === WebSocket.OPEN && current6DigitCode) {
                            ws.send(JSON.stringify({ type: 'hangup', code: current6DigitCode }));
                        }
                        resetStatesForTabSwitch();
                        break;
                    case "closed":
                        updateStatus(targetStatusEl, _('disconnected'));
                        // 意図的なクローズの場合もあるので、エラーとは限らない
                        break;
                }
            };

            if (isOfferer) {
                dataChannel = peerConnection.createDataChannel('fileBridgeChannel', { reliable: true });
                setupDataChannelEvents();
            } else {
                peerConnection.ondatachannel = (event) => {
                    dataChannel = event.channel;
                    setupDataChannelEvents();
                };
            }
        }

        function setupDataChannelEvents() {
            if (!dataChannel) return;
            dataChannel.binaryType = 'arraybuffer';

            dataChannel.onopen = () => {
                log('DataChannel OPEN');
                if (isOfferer && selectedFiles.length > 0 && (peerConnection.connectionState === 'connected' || peerConnection.connectionState === 'connecting')) { // connecting中でもDCが開くことあり
                    startFileTransfer();
                } else if (!isOfferer) {
                    updateStatus(receiveStatusEl, _('connectionEstablished') + " " + _('waitingForFiles') || "Waiting for files...");
                }
            };
            dataChannel.onclose = () => {
                log('DataChannel CLOSED');
            };
            dataChannel.onerror = (error) => {
                logError('DataChannel Error:', error);
                updateStatus(isOfferer ? sendStatusEl : receiveStatusEl, _('dataError'), true);
            };

            dataChannel.onmessage = (event) => {
                if (typeof event.data === 'string') {
                    try {
                        const message = JSON.parse(event.data);
                        handleReceivedData(message, true); // true for isMetadata
                    } catch (e) {
                        logError("Error parsing string message from DataChannel:", e, event.data);
                    }
                } else if (event.data instanceof ArrayBuffer) {
                    handleReceivedData(event.data, false); // false for isMetadata
                } else {
                    log("Received unknown data type on DataChannel:", event.data);
                }
            };
        }

        function handleReceivedData(data, isMetadata) {
            if (isMetadata) { // メタデータや制御メッセージ
                const message = data; // data is already parsed object
                if (message.type === 'file-metadata') {
                    log(`Received metadata for ${message.name}:`, message);
                    receivingFile = {
                        name: message.name, size: message.size, mimeType: message.mimeType, hash: message.hash,
                        buffer: [], receivedBytes: 0, totalFiles: message.totalFiles, currentFileNum: message.currentFileNum,
                        elementId: `receive-file-item-${message.name.replace(/[^a-zA-Z0-9]/g, '')}-${Date.now()}`
                    };
                    if (message.currentFileNum === 1) {
                        receivedFileListContainer.innerHTML = '';
                        totalBytesToReceive = message.totalSizeAllFiles || 0; // Offererが送るtotalSizeAllFilesを使用
                        totalBytesReceived = 0;
                        receiveOverallProgressContainer.style.display = 'block';
                        receiveOverallProgressBar.style.width = '0%'; receiveOverallProgressBar.textContent = '0%';
                    }
                    const fileElement = document.createElement('div'); fileElement.classList.add('file-item'); fileElement.id = receivingFile.elementId;
                    fileElement.innerHTML = `<span class="file-item-name">${receivingFile.name} (${formatBytes(receivingFile.size)})</span><span class="file-item-progress" id="progress-${receivingFile.elementId}">0%</span>`;
                    receivedFileListContainer.appendChild(fileElement);
                    updateStatus(receiveStatusEl, `${_('receivingFiles')} ${receivingFile.name} (${receivingFile.currentFileNum}/${receivingFile.totalFiles})`);
                } else if (message.type === 'all-files-sent') {
                    log("All files reported as sent by sender.");
                    updateStatus(receiveStatusEl, _('transferComplete'));
                    receiveButton.disabled = false; // Ready for new connection
                    connectCodeInput.disabled = false;
                } else if (message.type === 'file-ack' || message.type === 'file-nack') {
                    log(`Received ${message.type} for ${message.name}`);
                    // TODO: NACKの場合の再送ロジック (送信側)
                }
            } else { // ファイルチャンク (ArrayBuffer)
                if (!receivingFile.name) {
                    logError("Chunk received before metadata."); return;
                }
                receivingFile.buffer.push(data);
                receivingFile.receivedBytes += data.byteLength;
                totalBytesReceived += data.byteLength;

                const fileProgress = Math.round((receivingFile.receivedBytes / receivingFile.size) * 100);
                const progressEl = document.getElementById(`progress-${receivingFile.elementId}`);
                if (progressEl) progressEl.textContent = `${fileProgress}%`;


                let overallProgress = 0;
                if (totalBytesToReceive > 0) {
                    overallProgress = Math.round((totalBytesReceived / totalBytesToReceive) * 100);
                } else if (receivingFile.totalFiles > 0 && receivingFile.size > 0) { // totalBytesToReceive が不明な場合のフォールバック
                    const estimatedTotalForBatch = receivingFile.totalFiles * receivingFile.size; // これは不正確
                    if (estimatedTotalForBatch > 0)
                        overallProgress = Math.round(totalBytesReceived / estimatedTotalForBatch * 100);
                }
                updateOverallProgress('receive', Math.min(overallProgress, 100));

                if (receivingFile.receivedBytes === receivingFile.size) {
                    if (progressEl) progressEl.textContent = _('verifyingHash');
                    assembleAndVerifyFile(receivingFile);
                } else if (receivingFile.receivedBytes > receivingFile.size) {
                    logError("Received more bytes than expected for file:", receivingFile.name);
                    if (progressEl) progressEl.textContent = _('error');
                }
            }
        }


        async function createPeerConnectionAndOffer() {
            isOfferer = true;
            createPeerConnection();
            if (!peerConnection) return; // Creation failed

            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                log('Offer created and local description set.');

                // キューされたICE候補があればここで処理 (setLocalDescription後)
                if (peerConnection._queuedIceCandidates) {
                    peerConnection._queuedIceCandidates.forEach(candidate => {
                        if (candidate) peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(logError);
                    });
                    delete peerConnection._queuedIceCandidates;
                }


                if (ws && ws.readyState === WebSocket.OPEN && current6DigitCode) {
                    ws.send(JSON.stringify({
                        type: 'offer',
                        code: current6DigitCode,
                        sdp: offer.sdp
                    }));
                }
            } catch (e) {
                logError("Error creating offer:", e);
                updateStatus(sendStatusEl, _('error') + " " + e.message, true);
            }
        }

        async function createPeerConnectionAndAnswer(offerSdp, offerIceCandidates) {
            isOfferer = false;
            createPeerConnection();
            if (!peerConnection) return; // Creation failed

            try {
                await peerConnection.setRemoteDescription(new RTCSessionDescription({ type: 'offer', sdp: offerSdp }));
                log('Remote description (offer) set.');

                offerIceCandidates?.forEach(candidate => {
                    if (candidate) peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(e => logError("Error adding initial ICE candidate from offer:", e.toString()));
                });
                // キューされたICE候補があればここで処理 (setRemoteDescription後)
                if (peerConnection._queuedIceCandidates) {
                    peerConnection._queuedIceCandidates.forEach(candidate => {
                        if (candidate) peerConnection.addIceCandidate(new RTCIceCandidate(candidate)).catch(logError);
                    });
                    delete peerConnection._queuedIceCandidates;
                }


                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);
                log('Answer created and local description set.');
                if (ws && ws.readyState === WebSocket.OPEN && current6DigitCode) {
                    ws.send(JSON.stringify({
                        type: 'answer',
                        code: current6DigitCode,
                        sdp: answer.sdp
                    }));
                }
            } catch (e) {
                logError("Error creating answer:", e);
                updateStatus(receiveStatusEl, _('error') + " " + e.message, true);
            }
        }


        // --- Send Logic ---
        dropZone.addEventListener('click', () => fileInput.click());
        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => { dropZone.classList.remove('dragover'); });
        dropZone.addEventListener('drop', (e) => { e.preventDefault(); dropZone.classList.remove('dragover'); handleFiles(e.dataTransfer.files); });
        fileInput.addEventListener('change', (e) => { handleFiles(e.target.files); });

        function handleFiles(files) {
            selectedFiles = Array.from(files);
            fileListContainer.innerHTML = '';
            const placeholderEl = fileListContainer.querySelector('.file-item-placeholder');
            if (placeholderEl) placeholderEl.remove();

            if (selectedFiles.length > 0) {
                selectedFiles.forEach((file, index) => {
                    const fileElement = document.createElement('div'); fileElement.classList.add('file-item'); fileElement.id = `send-file-item-${index}`;
                    fileElement.innerHTML = `<span class="file-item-name">${file.name} (${formatBytes(file.size)})</span><span class="file-item-progress" id="send-file-progress-${index}">0%</span>`;
                    fileListContainer.appendChild(fileElement);
                });
                sendButton.disabled = false;
                updateStatus(sendStatusEl, `${selectedFiles.length} file(s) selected.`);
            } else {
                sendButton.disabled = true;
                // プレースホルダーを再度表示
                const placeholder = document.createElement('p');
                placeholder.classList.add('file-item-placeholder');
                placeholder.textContent = _('filePlaceholder');
                placeholder.style.textAlign = 'center';
                placeholder.style.color = '#6272a4';
                placeholder.style.padding = '20px 0';
                placeholder.style.background = 'none';
                fileListContainer.appendChild(placeholder);
                updateStatus(sendStatusEl, '');
            }
        }

        sendButton.addEventListener('click', async () => {
            if (selectedFiles.length === 0) {
                updateStatus(sendStatusEl, _('noFilesSelected'), true); return;
            }
            sendButton.disabled = true;
            updateStatus(sendStatusEl, _('initializingSender'));
            try {
                await initializeWebSocket();
                ws.send(JSON.stringify({ type: 'request-code' }));
            } catch (error) {
                logError("Failed to initialize WebSocket for sending:", error);
                updateStatus(sendStatusEl, _('wsError') + " " + error.message, true);
                sendButton.disabled = false;
            }
        });

        function startFileTransfer() {
            if (!dataChannel || dataChannel.readyState !== 'open') {
                logError("DataChannel not open. Cannot start transfer.");
                updateStatus(sendStatusEl, _('dataError') + " Channel not ready.", true);
                // Simple retry logic for DataChannel opening
                let retries = 5;
                const intervalId = setInterval(() => {
                    if (dataChannel && dataChannel.readyState === 'open') {
                        clearInterval(intervalId);
                        log("DataChannel opened after retry. Starting transfer.");
                        startFileTransferInternal();
                    } else if (--retries <= 0) {
                        clearInterval(intervalId);
                        logError("DataChannel did not open after retries.");
                        updateStatus(sendStatusEl, _('dataError') + " Channel failed to open.", true);
                    }
                }, 1000);
                return;
            }
            startFileTransferInternal();
        }

        function startFileTransferInternal() {
            currentFileIndex = 0;
            totalBytesToSend = selectedFiles.reduce((acc, file) => acc + file.size, 0);
            totalBytesSent = 0;
            updateOverallProgress('send', 0);
            sendOverallProgressContainer.style.display = 'block';
            sendOverallProgressBar.style.width = '0%'; sendOverallProgressBar.textContent = '0%'; // Reset progress bar explicitly
            sendFilesSequentially();
        }


        async function sendFilesSequentially() {
            if (currentFileIndex < selectedFiles.length) {
                const file = selectedFiles[currentFileIndex];
                updateStatus(sendStatusEl, `${_('sendingFiles')} ${file.name} (${currentFileIndex + 1}/${selectedFiles.length})`);
                const progressEl = document.getElementById(`send-file-progress-${currentFileIndex}`);
                if (progressEl) progressEl.textContent = _('calculatingHash');

                try {
                    const fileHash = await calculateFileHash(file);
                    if (progressEl) progressEl.textContent = '0%';

                    const metadata = {
                        type: 'file-metadata', name: file.name, size: file.size, mimeType: file.type, hash: fileHash,
                        totalFiles: selectedFiles.length, currentFileNum: currentFileIndex + 1,
                        isLastFile: currentFileIndex === selectedFiles.length - 1,
                        totalSizeAllFiles: totalBytesToSend
                    };
                    if (dataChannel && dataChannel.readyState === 'open') {
                        dataChannel.send(JSON.stringify(metadata));
                        log(`Sent metadata for ${file.name}:`, metadata);
                        sendFileInChunks(file, currentFileIndex);
                    } else {
                        logError("DataChannel not open when trying to send metadata.");
                        updateStatus(sendStatusEl, _('dataError') + " Cannot send metadata.", true);
                    }
                } catch (hashError) {
                    logError("Error calculating hash for file:", file.name, hashError);
                    if (progressEl) progressEl.textContent = _('error');
                    updateStatus(sendStatusEl, _('fileReadError') + " (hash calculation). Skipping file.", true);
                    currentFileIndex++; // Skip this file
                    sendFilesSequentially(); // Try next file
                }
            } else {
                updateStatus(sendStatusEl, _('transferComplete'));
                log("All files process attempted.");
                if (dataChannel && dataChannel.readyState === 'open') {
                    dataChannel.send(JSON.stringify({ type: 'all-files-sent' }));
                }
                sendButton.disabled = false;
            }
        }

        function sendFileInChunks(file, fileIndex) {
            const reader = new FileReader(); let offset = 0;
            const progressEl = document.getElementById(`send-file-progress-${fileIndex}`);

            reader.onload = (e) => {
                try {
                    if (dataChannel && dataChannel.readyState === 'open') {
                        dataChannel.send(e.target.result);
                        offset += e.target.result.byteLength; totalBytesSent += e.target.result.byteLength;
                        const fileProgress = Math.round((offset / file.size) * 100);
                        if (progressEl) progressEl.textContent = `${fileProgress}%`;
                        updateOverallProgress('send', Math.round((totalBytesSent / totalBytesToSend) * 100));

                        if (offset < file.size) {
                            if (dataChannel.bufferedAmount > CHUNK_SIZE * 16) { // Increased buffer check
                                setTimeout(() => readSlice(offset), 100); // Slightly longer timeout
                            } else {
                                readSlice(offset);
                            }
                        } else {
                            log(`${file.name} sent completely.`);
                            if (progressEl) progressEl.textContent = `100% (${_('fileSent')})`;
                            currentFileIndex++; sendFilesSequentially();
                        }
                    } else { logError("DC closed during chunk send."); updateStatus(sendStatusEl, _('disconnected') + " " + _('transferFailed'), true); }
                } catch (err) { logError("Err sending chunk: ", err); updateStatus(sendStatusEl, _('dataError') + " " + _('transferFailed'), true); }
            };
            reader.onerror = () => { logError('FileRead Err'); updateStatus(sendStatusEl, _('fileReadError'), true); if (progressEl) progressEl.textContent = _('error'); };
            function readSlice(o) {
                if (o < file.size) { // Ensure we don't read past the end
                    const slice = file.slice(o, o + CHUNK_SIZE);
                    reader.readAsArrayBuffer(slice);
                } else { // Should be caught by offset < file.size earlier, but as a safeguard
                    log(`${file.name} already fully processed or offset error.`);
                    if (progressEl) progressEl.textContent = `100% (${_('fileSent')})`;
                    currentFileIndex++; sendFilesSequentially();
                }
            }
            readSlice(0);
        }


        // --- Receive Logic ---
        receiveButton.addEventListener('click', async () => {
            const code = connectCodeInput.value.trim();
            if (!/^\d{6}$/.test(code)) {
                updateStatus(receiveStatusEl, _('invalidCode'), true); return;
            }
            current6DigitCode = code;
            receiveButton.disabled = true;
            connectCodeInput.disabled = true;
            updateStatus(receiveStatusEl, `${_('connecting')} (Code: ${code.match(/.{1,3}/g).join('-')})...`);
            try {
                await initializeWebSocket();
                ws.send(JSON.stringify({ type: 'join', code: current6DigitCode }));
            } catch (error) {
                logError("Failed to initialize WebSocket for receiving:", error);
                updateStatus(receiveStatusEl, _('wsError') + " " + error.message, true);
                receiveButton.disabled = false;
                connectCodeInput.disabled = false;
            }
        });

        async function assembleAndVerifyFile(fileData) {
            if (!fileData || !fileData.buffer || fileData.buffer.length === 0) {
                logError("Assemble and Verify called with invalid fileData:", fileData);
                const progressEl = document.getElementById(`progress-${fileData.elementId}`);
                if (progressEl) progressEl.textContent = _('error');
                return;
            }
            const receivedBlob = new Blob(fileData.buffer);
            fileData.buffer = []; // Clear buffer early to free memory

            try {
                const calculatedHash = await calculateFileHash(receivedBlob);
                log(`Calculated hash for ${fileData.name}: ${calculatedHash}, Expected: ${fileData.hash}`);
                const progressEl = document.getElementById(`progress-${fileData.elementId}`);

                if (calculatedHash === fileData.hash) {
                    log(`Integrity OK for ${fileData.name}`);
                    if (progressEl) progressEl.textContent = `100% (${_('fileReceived')})`;
                    const downloadLink = document.createElement('a');
                    downloadLink.href = URL.createObjectURL(receivedBlob);
                    downloadLink.download = fileData.name;
                    const fileItemEl = document.getElementById(fileData.elementId);
                    if (fileItemEl) {
                        const linkP = document.createElement('p'); linkP.style.textAlign = 'right'; linkP.style.fontSize = '0.8em';
                        downloadLink.textContent = _('downloadButtonText', `Download ${fileData.name}`);
                        linkP.appendChild(downloadLink); fileItemEl.appendChild(linkP);
                    }
                } else {
                    logError(`Hash mismatch for ${fileData.name}!`);
                    if (progressEl) progressEl.textContent = _('hashMismatch');
                    updateStatus(receiveStatusEl, `${_('hashMismatch')} for ${fileData.name}`, true);
                }
            } catch (hashError) {
                logError("Error calculating hash for received file:", fileData.name, hashError);
                const progressEl = document.getElementById(`progress-${fileData.elementId}`);
                if (progressEl) progressEl.textContent = _('error');
                updateStatus(receiveStatusEl, _('fileReadError') + " (hash verification).", true);
            }
        }

        // --- UI Update Functions ---
        function updateStatus(element, message, isError = false) {
            element.textContent = message; element.style.color = isError ? '#ff5555' : '#ffb86c';
        }
        function updateOverallProgress(type, progress) {
            const bar = type === 'send' ? sendOverallProgressBar : receiveOverallProgressBar;
            const container = type === 'send' ? sendOverallProgressContainer : receiveOverallProgressContainer;
            if (bar && container) {
                progress = Math.max(0, Math.min(100, progress)); // Ensure progress is between 0 and 100
                bar.style.width = progress + '%'; bar.textContent = progress + '%';
                container.style.display = 'block'; // Always show if there's any progress attempt
                if (progress === 100 && type === 'receive') {
                    // Optionally hide after a delay, or keep it to show completion
                    // setTimeout(() => { container.style.display = 'none'; bar.style.width = '0%'; bar.textContent = '0%'; }, 5000);
                }
                if (progress === 0 && container.style.display !== 'none' && type === 'send') { // Reset if 0
                    // container.style.display = 'none';
                }
            }
        }

        // --- Initialization ---
        document.addEventListener('DOMContentLoaded', () => {
            const preferredLang = localStorage.getItem('preferredLanguage');
            if (preferredLang && translations[preferredLang]) { currentLanguage = preferredLang; document.getElementById('languageSwitcher').value = preferredLang; }
            else { const browserLang = navigator.language.split('-')[0]; if (translations[browserLang]) { currentLanguage = browserLang; document.getElementById('languageSwitcher').value = browserLang; } }
            applyTranslations(); // これを最初に呼ぶ
            showTab('sendTab'); // その後タブ表示と関連リセット
        });
    </script>
</body>

</html>
